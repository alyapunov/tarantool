#include "salad/rtree.h"

#include <cstring>
#include <cmath>
#include <random>

#include <benchmark/benchmark.h>

//////////////////////// Constants  ////////////////////////
/* Min size of a hash table to test. */
static constexpr size_t MIN_SIZE = 10000;
/* Max size of a hash table to test. */
static constexpr size_t MAX_SIZE = 1000000;
/* Multiplier of a hash table size for iteration from MIN_SIZE to MAX_SIZE. */
static constexpr size_t SIZE_MULTIPLIER = 10;
/* Standard matras extent size. */
static constexpr size_t EXTENT_SIZE = 16 * 1024;
/* Number of iteration of select iterator. */
static constexpr size_t SELECT_LIMIT = 100;

//////////////////// Debug stat printer ////////////////////
/**
 * Compile time calculator of the number of sizes that google benchmark
 * will perform.
 * Mathematically it is log(MAX_SIZE / MIN_SIZE) / log(SIZE_MULTIPLIER),
 * rounded up.
 */
template <size_t Size, bool Oveflow = (Size > MAX_SIZE)>
struct NumEntryCalc {
	static constexpr size_t value =
		1 + NumEntryCalc<Size * SIZE_MULTIPLIER>::value;
};

template <size_t Size>
struct NumEntryCalc<Size, true> {
	static constexpr size_t value = 0;
};

#ifndef NDEBUG
/**
 * Simple min/max/average calculator of some value.
 * Prints the result to stdout upon destruction.
 */
struct DebugStat {
	struct Entry {
		unsigned long N;
		unsigned long min = SIZE_MAX;
		unsigned long max = 0;
		unsigned long total = 0;
		unsigned long count = 0;
	};
	static constexpr size_t NUM_ENTRY = NumEntryCalc<MIN_SIZE>::value;

	const char *name;
	unsigned long dimension;
	Entry entries[NUM_ENTRY];

	DebugStat(const char *aname, unsigned long adimension)
		: name(aname), dimension(adimension)
	{
		for (size_t i = 0, s = MIN_SIZE;
		     s < MAX_SIZE; s *= SIZE_MULTIPLIER, i++)
			entries[i].N = s;
		entries[NUM_ENTRY - 1].N = MAX_SIZE;
	}
	~DebugStat()
	{
		for (size_t i = 0; i < NUM_ENTRY; i++) {
			if (entries[i].count == 0)
				continue;
			printf("%s<%lu, %lu>(min, max, avg) = (%lu, %lu, %lf)\n",
			       name, dimension, entries[i].N,
			       entries[i].min, entries[i].max,
			       double (entries[i].total) / entries[i].count);
		}
	}
	void account(unsigned long rtree_size, unsigned long value)
	{
		Entry *e = nullptr;
		size_t i = 0;
		for (; i < NUM_ENTRY; i++)
			if (entries[i].N == rtree_size)
				break;
		assert(i < NUM_ENTRY);
		if (entries[i].min > value)
			entries[i].min = value;
		if (entries[i].max < value)
			entries[i].max = value;
		entries[i].total += value;
		entries[i].count++;
	}
};
#else // #ifndef NDEBUG
/**
 * Disabled in release.
 */
struct DebugStat {
	DebugStat(const char *, unsigned long) {}
	void account(unsigned long, unsigned long) {}
};
#endif // #ifndef NDEBUG


////////////////// Random box generation  //////////////////
/**
 * Simple double random. Returns [0, 1] random value.
 */
static double
drand()
{
	return (double)rand() / RAND_MAX;
}

/**
 * General multidimensional box. Can be converted to rtree_rect.
 */
template <size_t Dimension>
struct Box {
	double coords[Dimension * 2];
	struct rtree_rect *
	get()
	{
		thread_local rtree_rect rt;
		memcpy(rt.coords, coords, sizeof(rt.coords[0]) * 2 * Dimension);
		return &rt;
	}
};

/**
 * Random point generator; the point has [0, 1) coordinates for each axis.
 */
template <size_t Dimension>
struct RandPoint : Box<Dimension> {
	using Box<Dimension>::coords;
	void generate()
	{
		for (size_t i = 0; i < Dimension; i++)
			coords[i * 2 + 0] = coords[i * 2 + 1] = drand();
	}
};

/**
 * Random point + data generator; the point has [0, 1) coordinates for each
 * axis, data (id) is not actually random and is set to given value.
 */
template <size_t Dimension>
struct RandPointData : RandPoint<Dimension> {
	uintptr_t id;
	void generate(uintptr_t aid)
	{
		id = aid;
		RandPoint<Dimension>::generate();
	}
private:
	using RandPoint<Dimension>::generate;
};

/**
 * Random box generator; the box size is selected to enclose about
 * SELECT_LIMIT points from N points generated by RandPoint.
 */
template <size_t Dimension>
struct RandLimitedBox : Box<Dimension> {
	using Box<Dimension>::coords;
	static double width(size_t N)
	{
		/*
		 * Volume == 1 contains N points.
		 * Volume == width ^ Dimension contains SELECT_LIMIT points.
		 * width ^ Dimension == SELECT_LIMIT / N;
		 * width = (SELECT_LIMIT / N) ^ (1 / Dimension).
		 */
		double width = std::pow(double(SELECT_LIMIT) / N,
					1. / Dimension);
		return width;
	}
	void generate(double width)
	{
		for (size_t i = 0; i < Dimension; i++) {
			/*
			 * The first coordinate must be in [0, 1 - width) range.
			 */
			coords[i * 2 + 0] = drand() * (1 - width);
			coords[i * 2 + 1] = coords[i * 2 + 0] + width;
		}
	}
};

/**
 * Universal test search box.
 * Is LimitedBox for SOP_BELONGS or RandPoint for SOP_NEIGHBOR.
 */
template <size_t Dimension, enum spatial_search_op Operation>
struct SearchBox;

template <size_t Dimension>
struct SearchBox<Dimension, SOP_BELONGS> : RandLimitedBox<Dimension> {};

template <size_t Dimension>
struct SearchBox<Dimension, SOP_NEIGHBOR> : RandPoint<Dimension> {
	static double width(size_t) { return 0.; }
	void generate(double) { RandPoint<Dimension>::generate(); }
private:
	using RandPoint<Dimension>::generate;
};

/////////////////// Rtree wrapper class  ///////////////////
/**
 * Global rtree extent alloc counter. Must be 0 after all trees destruction.
 */
size_t extent_count = 0;

/**
 * Convenient rtree wrapper class.
 */
template <size_t Dimension>
struct RTree {
	RTree()
	{
		create();
	}

	~RTree()
	{
		destroy();
	}

	void create()
	{
		rtree_init(&tree, Dimension, EXTENT_SIZE, extent_alloc,
			   extent_free, nullptr, RTREE_EUCLID);
	}

	void destroy()
	{
		rtree_destroy(&tree);
	}

	void recreate()
	{
		destroy();
		create();
	}

	void insert(RandPointData<Dimension>& rt)
	{
		rtree_insert(&tree, rt.get(), (void *)rt.id);
	}

	void insert(std::vector<RandPointData<Dimension>> &vec)
	{
		for (auto &rt : vec)
			insert(rt);
	}

	void remove(RandPointData<Dimension>& rt)
	{
		rtree_remove(&tree, rt.get(), (void *)rt.id);
	}

	void remove(std::vector<RandPointData<Dimension>> &vec)
	{
		for (auto &rt : vec)
			remove(rt);
	}

	/** Search for one value. Return stored record. */
	uintptr_t search(Box<Dimension> &box, enum spatial_search_op op)
	{
		struct rtree_iterator itr;
		rtree_iterator_init(&itr);
		if (!rtree_search(&tree, box.get(), op, &itr)) {
			rtree_iterator_destroy(&itr);
			return 0;
		}
		uintptr_t res = (uintptr_t)rtree_iterator_next(&itr);
#ifndef NDEBUG
		if (op == SOP_NEIGHBOR) {
			static DebugStat stat("SearchNeighTreeSize", Dimension);
			stat.account(rtree_number_of_records(&tree),
				     rtree_iterator_neigh_tree_size(&itr));
		}
#endif
		rtree_iterator_destroy(&itr);
		return res;
	}

	/**
	 * Search and iterate.
	 * For SOP_NEIGHBOR the iteration is explicitly limited to SELECT_LIMIT.
	 * For SOP_BELONGS the iteration is expected to be approximately
	 *  SELECT_LIMIT due to specially calculated box size.
	 * Return the number of iterated records.
	 */
	size_t iterate(Box<Dimension> &box, enum spatial_search_op op)
	{
		struct rtree_iterator itr;
		rtree_iterator_init(&itr);
		size_t count = 0;
		if (!rtree_search(&tree, box.get(), op, &itr)) {
			rtree_iterator_destroy(&itr);
			count = 1; // Accept zero-size result as one operation.
		} else {
			while (true) {
				if (rtree_iterator_next(&itr) == NULL)
					break;
				count++;
				if (op == SOP_NEIGHBOR && count == SELECT_LIMIT)
					break;
			}
#ifndef NDEBUG
			if (op == SOP_NEIGHBOR) {
				static DebugStat stat("IterateNeighTreeSize", Dimension);
				stat.account(rtree_number_of_records(&tree),
					     rtree_iterator_neigh_tree_size(&itr));
			} else {
				static DebugStat stat("IterateBelongCount", Dimension);
				stat.account(rtree_number_of_records(&tree),
					     count);
			}
#endif
		}
		return count;
	}

	size_t size()
	{
		return rtree_number_of_records(&tree);
	}

	static void *extent_alloc(void *)
	{
		extent_count++;
		return malloc(EXTENT_SIZE);
	}

	static void extent_free(void *, void *p)
	{
		extent_count--;
		free(p);
	}

	rtree tree;
};

/**
 * Cheap and easy checker that extent_count is zero upon construction and
 * destruction. Just aborts execution if not.
 */
struct CheckExtents {
	static size_t checkers_count;
	CheckExtents() {
		if (checkers_count == 0 && extent_count != 0)
			abort();
		checkers_count++;
	}
	~CheckExtents() {
		--checkers_count;
		if (checkers_count == 0 && extent_count != 0)
			abort();
	}
};
size_t CheckExtents::checkers_count = 0;

///////////////////// Random test data /////////////////////
/**
 * Rtree holder and generator of given count of records to be inserted to rtree.
 * Prepares rtree for insertion/remove of generated records.
 */
template <size_t Dimension>
struct TestData : CheckExtents {
	std::vector<RandPointData<Dimension>> data;
	RTree<Dimension> tree;
	size_t data_pos = 0;

	/** Get next unique ID of a record. */
	static size_t get_next_id()
	{
		static size_t id = 0;
		return ++id;
	}

	/** Check whether new data must be generated. */
	bool need_more()
	{
		return data_pos == data.size();
	}

	/** Get the next record for insertion/removal. */
	RandPointData<Dimension> &next()
	{
		return data[data_pos++];
	}

	/** Generate new data. */
	void regenerate_data(benchmark::State& state, size_t N)
	{
		state.PauseTiming();
		regenerate_data(N);
		state.ResumeTiming();
	}

	/** Randomize data and return to the beginning of iteration. */
	void restart_data(benchmark::State& state)
	{
		state.PauseTiming();
		restart_data();
		state.ResumeTiming();
	}

	/** Prepare empty rtree and amount of data for insertion. */
	void prepare_empty(benchmark::State& state, size_t N)
	{
		state.PauseTiming();
		if (tree.size() != data.size())
			abort();
		tree.recreate();
		regenerate_data(N);
		state.ResumeTiming();
	}

	/** Prepare full size rtree and amount of data for removal. */
	void prepare_full(benchmark::State& state, size_t N)
	{
		state.PauseTiming();
		if (tree.size() != 0)
			abort();
		regenerate_data(N);
		tree.insert(data);
		restart_data();
		state.ResumeTiming();
	}

private:
	/* Internal regenerate that does not stop timing. */
	void regenerate_data(size_t N)
	{
		data.resize(N);
		for (auto &p : data)
			p.generate(get_next_id());
		data_pos = 0;
	}

	/* Internal restart that does not stop timing. */
	void restart_data()
	{
		std::shuffle(data.begin(), data.end(),
			     std::mt19937{std::random_device{}()});
		data_pos = 0;
	}
};

/**
 * Generator of given count of boxes for selection from rtree.
 * For SOP_NEIGHBOR it's an amount for random points,
 * for SOP_BELONGS it's an amount of boxes that probably contains SELECT_LIMIT
 * points in rtree.
 */
template <size_t Dimension, enum spatial_search_op Operation>
struct SearchData {
	std::vector<SearchBox<Dimension, Operation>> data;
	size_t data_pos = 0;

	/** Check whether new data must be generated. */
	bool need_more()
	{
		return data_pos == data.size();
	}
	/** Get the next box for selection. */
	SearchBox<Dimension, Operation> &next()
	{
		return data[data_pos++];
	}
	/** Generate new data for selection. */
	void prepare(benchmark::State& state, size_t N)
	{
		state.PauseTiming();
		data.resize(N);
		double width = SearchBox<Dimension, Operation>::width(N);
		for (auto &rt : data)
			rt.generate(width);
		data_pos = 0;
		state.ResumeTiming();
	}
};

//////////////////////// Benchmarks ////////////////////////
/**
 * Insert state.range() records to rtree.
 */
template <size_t Dimension>
static void BM_Insert(benchmark::State& state)
{
	size_t N = state.range();
	TestData<Dimension> data;
	int64_t op_count = 0;

	for (auto _ : state) {
		if (data.need_more())
			data.prepare_empty(state, N);
		data.tree.insert(data.next());
		op_count++;
	}

	state.SetItemsProcessed(op_count);
}

/**
 * Remove state.range() records from rtree.
 */
template <size_t Dimension>
static void BM_Remove(benchmark::State& state)
{
	size_t N = state.range();
	TestData<Dimension> data;
	int64_t op_count = 0;

	for (auto _ : state) {
		if (data.need_more())
			data.prepare_full(state, N);
		data.tree.remove(data.next());
		op_count++;
	}

	state.SetItemsProcessed(op_count);
}

/**
 * Continuously repeat remove + insert.
 */
template <size_t Dimension>
static void BM_LifeCycle(benchmark::State& state)
{
	size_t N = state.range();
	TestData<Dimension> data1;
	TestData<Dimension> data2;
	TestData<Dimension> *pdata1 = NULL;
	TestData<Dimension> *pdata2 = NULL;
	int64_t op_count = 0;

	/*
	 * Use only data1.tree.
	 * Remove records from pdata1.
	 * Insert records from pdata2.
	 */
	for (auto _ : state) {
		if (data1.need_more()) {
			assert(data2.need_more());
			if (pdata1 == NULL) {
				data1.prepare_full(state, N);
				data2.prepare_empty(state, N);
				pdata1 = &data1;
				pdata2 = &data2;
			} else {
				if (data1.tree.size() != N)
					abort();
				std::swap(pdata1, pdata2);
				pdata1->restart_data(state);
				pdata2->regenerate_data(state, N);
			}
		}
		data1.tree.remove(pdata1->next());
		data1.tree.insert(pdata2->next());
		op_count++;
	}

	state.SetItemsProcessed(op_count);
}

/**
 * Search for the first record from rtree of size state.range().
 */
template <size_t Dimension, enum spatial_search_op Operation>
static void BM_Search(benchmark::State& state)
{
	size_t N = state.range();
	TestData<Dimension> data;
	SearchData<Dimension, Operation> search_data;
	int64_t op_count = 0;

	for (auto _ : state) {
		if (data.need_more())
			data.prepare_full(state, N);
		if (search_data.need_more())
			search_data.prepare(state, N);
		benchmark::DoNotOptimize(
			data.tree.search(search_data.next(), Operation));
		op_count++;
	}

	state.SetItemsProcessed(op_count);
}

/**
 * Search and select SELECT_LIMIT record from rtree of size state.range().
 * Note that rps is counted for each record, not for entire select.
 */
template <size_t Dimension, enum spatial_search_op Operation>
static void BM_Iterate(benchmark::State& state)
{
	size_t N = state.range();
	TestData<Dimension> data;
	SearchData<Dimension, Operation> search_data;
	int64_t op_count = 0;

	for (auto _ : state) {
		if (data.need_more())
			data.prepare_full(state, N);
		if (search_data.need_more())
			search_data.prepare(state, N);
		op_count += data.tree.iterate(search_data.next(), Operation);
	}

	state.SetItemsProcessed(op_count);
}

void setup(benchmark::internal::Benchmark* benchmark)
{
	benchmark->RangeMultiplier(SIZE_MULTIPLIER)->Range(MIN_SIZE, MAX_SIZE);
}

BENCHMARK_TEMPLATE(BM_Insert, 2)->Apply(setup);
BENCHMARK_TEMPLATE(BM_Remove, 2)->Apply(setup);
BENCHMARK_TEMPLATE(BM_LifeCycle, 2)->Apply(setup);
BENCHMARK_TEMPLATE(BM_Search, 2, SOP_BELONGS)->Apply(setup);
BENCHMARK_TEMPLATE(BM_Search, 2, SOP_NEIGHBOR)->Apply(setup);
BENCHMARK_TEMPLATE(BM_Iterate, 2, SOP_BELONGS)->Apply(setup);
BENCHMARK_TEMPLATE(BM_Iterate, 2, SOP_NEIGHBOR)->Apply(setup);

BENCHMARK_TEMPLATE(BM_Insert, 8)->Apply(setup);
BENCHMARK_TEMPLATE(BM_Remove, 8)->Apply(setup);
BENCHMARK_TEMPLATE(BM_LifeCycle, 8)->Apply(setup);
BENCHMARK_TEMPLATE(BM_Search, 8, SOP_BELONGS)->Apply(setup);
BENCHMARK_TEMPLATE(BM_Search, 8, SOP_NEIGHBOR)->Apply(setup);
BENCHMARK_TEMPLATE(BM_Iterate, 8, SOP_BELONGS)->Apply(setup);
BENCHMARK_TEMPLATE(BM_Iterate, 8, SOP_NEIGHBOR)->Apply(setup);

BENCHMARK_MAIN();

#include "debug_warning.h"
